- OOP giúp scale chương trình thông qua việc quản lý các phương thức thông qua class, có thể thay đổi hoặc thêm các thuộc tính cho các class con một cách nhanh chóng.
- Trước đây các phần mềm phát triển theo hướng functional, tiếp cận theo hướng chức năng, cần gì thì thêm vào thôi, sửa 1 chức năng đôi khi cần phải sửa đổi các chức năng khác liên quan, do đó dẫn đến việc bảo trì rất cao, bây giờ sử dụng OOP dễ mở rộng phần mềm. Tránh hiệu ứng domino, xử lý chỗ này thì cần phải xử lý n chỗ khác, và nhiều khi còn ảnh hưởng đến hoạt động của hệ thống.
- Đưa các thông tin của đối tượng vào trong lập trình, đối tượng có các thông tin về thuộc tính và phương thức của đối tượng đó.
- Sử dụng Visual paradigm hoặc draw.io để mô tả các lớp đối tượng trước khi xây dựng chương trình.
- Cần phân tích các lớp đối tượng của chương trình. Thường các đối tượng có mối liên hệ với nhau. VD LopHoc có chứa giaoVienDungLop, dsHocSinh.
- Cấu trúc file trong JAVA, quản lý theo package, tên package được đặt chữ thường, thường đặt theo doman.
- Trường hợp từ package này truy cập package khác thì cần phải có thuộc tính public mới truy cập được thuộc tính, nó quy định ở nơi nào được access vào thuộc tính đó.
- Khi tạo một biến thì biến sẽ lưu trên stack, còn object được new thì sẽ lưu trên heap. biến = new object thì biến trên stack sẽ trỏ tới địa chỉ vùng nhớ chứa object được new trên heap. Trường hợp tạo biến = new object mà sau đó trỏ biến đó tới ô vùng nhớ khác => object đã tạo sẽ không được link tới, sẽ bị JAVA kill thông qua garbage collection.
- Nguyên tắc SOLID, KISS, DRY. 
- Bảo trì là người ta cần nhiều chức năng nên cập nhật lên, sau đó gặp lỗi thì cần phải fix lỗi gọi là bảo trì. 
==Tính đóng gói==
- Đem những data, những function vào chung 1 đơn vị. Đây là tính chất quan trọng nhất của tính đóng gói, bình thường function muốn chạy thì cần phải truyền param vào, trường hợp đối tượng có 100 thuộc tính thì có thể truyền tới 100 params, nếu mà truyền nhiều param dễ xảy ra lỗi (do nếu truyền không đúng thứ tự hoặc truyền thiếu sẽ lỗi).
- Phương thức của object không cần truyền tham số mà sẽ nhận giá trị các thuộc tính của bản thân object đó.
- Contructors: là hàm khởi tạo, khởi tạo giá trị ban đầu cho các thuộc tính của object. Có thể viết nhiều hàm khởi tạo cho cùng 1 đối tượng, các hàm khởi tạo này phải khác nhau về tham số truyền vào (khác nhau về kiểu dữ liệu truyền vào). Từ khóa this đại diện cho chính đối tượng đó.
- Các loại access modifier: công dụng là quy định việc truy cập đến các thuộc tính và phương thức của đối tượng thông qua các từ khóa public, protected, private, default
	- public: ở đâu cũng truy cập được.
	- private: chỉ ở trong nội bộ lớp mới truy cập được.
	- protected: chỉ ở trong cùng package và các lớp kế thừa.
	- default: là mặc định, bỏ trắng không điền, chỉ ở trong cùng package và các lớp kế thừa.
	- Lưu ý: protected và default có thể truy cập ở trong classPath khi thực hiện test.
- Dùng các phương thức getter và setter để tránh việc truy xuất trực tiếp vào các thuộc tính của object. Giúp tăng tính bảo mật và sự ổn định cho chương trình. Việc khai báo setter và getter cho các thuộc tính private là không bắt buộc (trường hợp không muốn thuộc tính được thấy bởi bất kỳ lớp nào) hoặc chỉ khai báo getter cho thuộc tính private nào đó nếu muốn thuộc tính đó chỉ được xem, không được sửa chữa hoặc chỉ xây dựng setter cho thuộc tính nếu muốn thuộc tính có khả năng chỉnh sửa từ bên ngoài mà không được xem. Tóm lại getter và setter là một cách đóng gói dữ liệu của lớp, chúng ta có thể chỉ định được thuộc tính nào đó hoàn toàn ẩn, chỉ đọc, chỉ ghi hoặc có thể đọc và ghi, đây là một cách giúp code được tường minh hơn.
- Tính toán entropy (tính toán được sự hỗn loạn), password càng hỗn loạn thì mật khẩu càng tốt.
- Các phần mềm lớn sẽ cập nhật document, sau đó mới cập nhật chương trình.
==Tính kế thừa==
- Thể hiện trên lớp đối tượng là mũi tên rỗng không fill.
- Tất cả các lớp con được xây dựng dựa trên nền của lớp cha
- Tính kế thừa giúp đơn giản hóa thiết kế và cài đặt ứng dụng, giúp dễ bảo trì, phát triển và phân tích bài toán.
- Cây kế thừa: từ một nhánh ban đầu sẽ tách ra nhiều nhánh nhỏ.
- Trong clas có kế thừa nếu set protected thì những thằng con kế thừa tính chất hoặc thuộc tính đó, còn private thì không.
- Test-coverage: Tỷ lệ % code được chạy / code viết ra, tối ưu là 100%.
- Trong quá trình làm thì làm tới đâu nên test tới đó (cuốn chiếu) đảm bảo code chạy đúng, tránh trường hợp code 100% rồi mới test thì nếu lỗi sẽ khó debug
- Khi tạo class mà không khai báo contructor thì JAVA sẽ tự tạo 1 contructor không tham số, nếu class có các thuộc tính kiểu string hoặc kiểu tham chiếu thì giá trị mặc định là null, các kiểu khác sẽ là 0. Trường hợp có 1 contructor bất kỳ nào trong class thì JAVA sẽ hủy cơ chế này => khi tạo 1 contructor truyền tham số thì phải tạo 1 contructor rỗng để khởi tạo giá trị ban đầu.
- Trong class con muốn gọi chỉ định phương thức của lớp cha thì sử dụng từ khóa super, nếu không thì nó mặc định sẽ gọi contructor không tham số.
- Nguyên tắc code OOP thì sẽ code từ lớp nào mà không xài lớp khác.
- Trong lập trình càng cao thì càng hướng tới decouple, nghĩa là tách các class ra tránh việc ảnh hưởng tới nhau. VD tránh việc trong lớp NhânViên lại có Object trưởng phòng, mà thay vào đó sẽ lưu string maNV của trưởng phòng quản lý.
- Có thể khai báo class nhân sự thông qua contructor của class con kế thừa (do class con kế thừa các thuộc tính và phương thức của class nhân sự + các thuộc tính và phương thức của lớp con => vùng nhớ lớn). Có thể ép kiểu lớp nhân sự về class con kế thừa để sử dụng các thuộc tính và phương thức của lớp con. 
- Để kiểm tra kiểu dữ liệu của một biến có thể sử dụng từ khóa instanceof(tên biến).
- 